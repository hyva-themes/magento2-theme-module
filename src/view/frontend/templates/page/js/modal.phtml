<?php
/**
 * Hyvä Themes - https://hyva.io
 * Copyright © Hyvä Themes 2020-present. All rights reserved.
 * This product is licensed per Magento install
 * See https://hyva.io/license
 */

declare(strict_types=1);

/** @var \Magento\Framework\View\Element\Template $block */
/** @var \Magento\Framework\Escaper $escaper */
/** @var \Hyva\Theme\Model\ViewModelRegistry $viewModels */

?>
<script>
    'use strict';

    (function () {
        const stack = [];

        function setSiblingsInert(dialogElement, toState) {
            // Walk up the DOM, toggle inert attribute the siblings at each level
            let el = dialogElement;
            while (el && (el = el.parentElement)) {
                if (el === document.body || el.parentElement === null) continue;

                [...el.parentElement.children].filter(sibling => sibling !== el).forEach(sibling => {
                    sibling.inert = toState;
                })
            }
        }

        function focusables(dialogElement) {
            return [...dialogElement.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])')]
                .filter(el => !el.hasAttribute('disabled'));
        }

        function firstVisible(elements) {
            const a = Array.from(elements);
            for (let i = 0; i < a.length; i++) {
                if (a[i].offsetWidth || a[i].offsetHeight || a[i].getClientRects().length) return a[i];
            }
            return null;
        }

        function setFocusAfterTransition(dialogElement, duration) {
            window.setTimeout(() => {
                const focusElement = firstVisible(dialogElement.querySelectorAll('[x-focus-first]')) ||
                    focusables(dialogElement)[0] || null;
                focusElement && focusElement.focus();
            }, duration + 1);
        }

        function ucFirst(s) {
            return s.substr(0, 1).toUpperCase() + s.substr(1);
        }

        function isOpenProp(dialogName) {
            return 'is' + ucFirst(dialogName) + 'Open';
        }

        function determineTrigger(refs, dialog, trigger) {
            // if show() was called without arguments use the event target as open trigger
            if (typeof trigger === 'undefined' && typeof dialog === 'object' && dialog.target && dialog.target.focus) {
                return dialog.target;
            }
            // if show('name', $event) was called with the event as the second argument use the event target as trigger
            if (typeof dialog === 'string' && typeof trigger === 'object' && trigger.target && trigger.target.focus) {
                return trigger.target;
            }
            // if show('name', 'trigger') was called with the ref name of the trigger element use that as the trigger
            if (typeof trigger === 'string' && refs[trigger]) {
                return refs[trigger];
            } else {
                // unknown trigger - no focus will be set when the dialog is hidden.
                return null;
            }
        }

        window.hyva.modal = function(options) {

            const config = Object.assign({
                dialog: 'dialog', // default dialog ref name
                trigger: 'trigger', // default trigger ref name (to focus when modal is closed)
                duration: 300, // ms before allowing subsequent hiding of modals for nested modals (see transition duration)
                transitionEnter: 'transition ease-out duration-300',
                transitionEnterStart: 'opacity-0',
                transitionEnterEnd: 'opacity-100',
                transitionLeave: 'transition ease-in duration-300',
                transitionLeaveStart: 'opacity-100',
                transitionLeaveEnd: 'opacity-0',
            }, options);
            let lastHide = 0;

            return {
                ['show'](dialog, trigger) {
                    const focusTargetAfterHide = determineTrigger(this.$refs, dialog, trigger);
                    const name = typeof dialog === 'string' ? dialog : config.dialog;
                    const dialogElement = this.$refs[name];

                    this[isOpenProp(name)] = true;
                    setSiblingsInert(dialogElement, true);
                    setFocusAfterTransition(dialogElement, config.duration);

                    stack.push({name, viewModel: this, focusTarget: focusTargetAfterHide, time: Date.now()});
                    if (stack.length === 1) {
                        document.body.classList.add('overflow-hidden');
                    }
                },
                ['hide']() {
                    // Guard against Escape being pressed multiple times before a transition is finished, otherwise
                    // this function will pop further dialogs from the stack but the display will not update.
                    if (Date.now() - lastHide < config.duration) {
                        return;
                    }
                    lastHide = Date.now();

                    const modal = stack.pop() || {};
                    const name = modal.name;
                    const nextFocusAfterHide = modal.focusTarget || this.$refs[config.trigger];
                    const dialogElement = this.$refs[name];

                    this[isOpenProp(name)] = false;
                    setSiblingsInert(dialogElement, false);
                    nextFocusAfterHide && this.$nextTick(() => {
                        nextFocusAfterHide.focus()
                    });

                    if (stack.length === 0) {
                        document.body.classList.remove('overflow-hidden');
                    }
                },
                [isOpenProp(config.dialog)]: false,
                ['overlay'](dialog) {
                    const name = typeof dialog === 'string' ? dialog : config.dialog;
                    return {
                        ['x-show']() {
                            return this[isOpenProp(name)];
                        },
                        ['x-transition:enter']: config.transitionEnter,
                        ['x-transition:enter-start']: config.transitionEnterStart,
                        ['x-transition:enter-end']: config.transitionEnterEnd,
                        ['x-transition:leave']: config.transitionLeave,
                        ['x-transition:leave-start']: config.transitionLeaveStart,
                        ['x-transition:leave-end']: config.transitionLeaveEnd,
                    };
                }
            };
        }

        window.hyva.modal.pop = function () {
            if (stack.length > 0) {
                const modal = stack[stack.length -1];
                modal.viewModel.hide();
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                window.hyva.modal.pop();
            }
        });

        // add generic modal @click.away handler
        document.addEventListener('click', function(e) {
            if (stack.length > 0) {
                const modal = stack[stack.length -1];
                if (modal.time + 10 < Date.now() && ! modal.viewModel.$refs[modal.name].contains(e.target)) {
                    modal.viewModel.hide();
                }
            }
        });
    })();
</script>
